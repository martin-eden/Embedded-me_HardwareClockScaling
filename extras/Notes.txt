(
  Niklaus Wirth:

    Algorithms + Data Structures = Programs

  Okay, but then

    Programs + Data = Tools

  I understood this writing this module.

  Below are development notes that lead me here.
)
(
  (
    [me_HardwareClockScaling] provides data structure and methods
    for hardware time scaling. Not data.

    Each module that uses this calculator should know it's specs.
  )

  (
    Well, that won't work

    Counters module don't want this yet. It does not deal with
    frequencies, it provides interface to hardware counters.
    Which is wider scope but less abstractions.

    UART module don't need this yet. It uses frequency for speed
    setting. But speed setting is one of several things it does.
    It calculates frequency with similar formulas but not exposing
    abstraction for them.

    Frequency generator deals with frequencies. But it's
    implementation uses just one counter of three available.
    And it can't switch to another externally specified
    counter (yet?).

    So looks like it's gonna become another code heap which
    noone wants to host and maintain but everyone wants to use.
    Like [me_StreamsCollection].
  )

  (
    Okay, I have idea

    We rename module from "Frequency Calculator" to
    "Hardware Duration Options" making it data-centric.

    So intention will become provision of available hardware duration
    options. And functions to calculate hardware duration from
    frequency and back will become just companion functions.
  )
)

(
  In ATmega328 hardware counters and UART (and maybe other modules)
  need to set speed slower than base clock speed.

  They are using "prescaler". Which is just integer power of two.
  For prescaler 1024 hardware module will run at each 1024th tick.

  (Well, that's speculation and abstraction for explanation.)

  Prescaler defines temporal granularity.

  And to store number of time granules another integer is used.
  For UART it's 10-bit int, for counters it's 8- or 16-bit.
)
